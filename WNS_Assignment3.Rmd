---
title: "WNS_Assignment3"
author: "Saikrishna_Javvadi"
output: 
  pdf_document:
    toc: true
    number_sections: true
    df_print: kable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Question 1
Generating the plot as described/shown in the question. As a GNP is generated by a random process, there will be variations in the network created each time the GNP function is run. For a given value of n ,I ran the GNP function several times, measuring the APL and estimated APL of the resulting network each time and then taken the average APL and average estimated APL for the GNP networks at that value of n.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#Importing the required libraries
library(igraph)
library(igraphdata)
library(igraph)
library(scales)
library(tidyr)
library(ggplot2)
library(jsonlite)
library(purrr)
library(data.table)
library(knitr)
library(kableExtra)

```
```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#creating a vector of edges from 0 to 1500 with a difference of 50
n<- seq(50,1500,50)
p<-0.01
act_list<-NULL
est_list<-NULL

#Iterating for 10 times to get the average
for (a in c(1:10)){
i<- 1
gnp<- NULL
for (x in n){
  gnp[[i]] <- sample_gnp(x, p)
  i<- i+1
}
j<-1
gnp.ave_degree <- NULL
#list to hold all the different estimated values of avg_path_length for different num_of_vertices respectively
gnp.apl.estimate <- NULL
#list to hold all the different actual values of avg_path_length for different num_of_vertices respectively
gnp.apl.actual <- NULL
#Iterating through each graph with different number of vertices
for (x in gnp){
  #calculate average degree : from theorem 1 total degree = 2 x num edges
  # average degree is total degree/number of nodes
  gnp.ave_degree[j] <- 2 * ecount(x)/vcount(x)
  #Estrimated Average path length
  gnp.apl.estimate[j] <- log(n[j])/log(gnp.ave_degree[j])
  #Actual Average path length
  gnp.apl.actual[j] <- mean_distance(x)
  j <-j+1
}
act_list[[a]]<- gnp.apl.actual
est_list[[a]]<- gnp.apl.estimate
}
xxx<-as.data.frame(est_list)
gnp.apl.estimate<-rowMeans(xxx)
yyy<-as.data.frame(act_list)
gnp.apl.actual<-rowMeans(yyy)

#creating  a dataframe from the above variables
df <- data.frame(num_vertices=n, Estimated_APL= gnp.apl.estimate, Actual_APL=gnp.apl.actual)
#creating a tidy dataframe using the pivot_longer function of tidyverse to plot the ggplot graphs
tidy_df <- pivot_longer(df,-num_vertices,names_to="estimate_actual",values_to="avg_path_length")

#Plotting the graph
ggplot(tidy_df,aes(x=num_vertices,y=avg_path_length,colour=estimate_actual,shape=estimate_actual))+
    geom_point()+
    geom_line(aes(linetype=estimate_actual))+
    scale_color_manual(values=c("red","blue"),name = "estimate_actual")+
    scale_shape_manual(values=c(16,18),name = "estimate_actual")+
    scale_linetype_manual(values=c("solid", "longdash"))+
    scale_y_continuous(limits=c(0, 15),breaks= c(0,2,4,5,6,8,10,12,14,15))+
    scale_x_continuous(breaks=c(0,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500))+
    labs(title ="GNP,p=0.01; Average Path Length vs n")+
    xlab("Number of Vertices, n")+
    ylab("Average Path Length")+
    theme_bw()+
    theme(axis.text = element_text(size=10),
          axis.title = element_text(size=10),
          legend.title = element_text(face="bold",size=9),
          legend.text = element_text(face="italic",size=10),
          plot.title = element_text(hjust=0.5),
          legend.position = c(0.8, 0.7))

```

# Question 2
Analyse the region of the plot where there is a rapid increase followed by a rapid decrease in APL. Examine the parameter values and graph measurements that are associated with this range of n. E.g. what are average degree values and clustering coefficients in this region. What do you observe?

->By definition, Average path length is the average of the shortest path distances between all pairs of nodes in the network.\
->Many man-made,social and biological networks which are usually very large have  short average path lengths which indicates that the network is potentially efficient at transmitting information, this can also be explained by the "Six degrees of separation phenomenon".\
->Also we can observe from the graph that the Average Path Lengths of real-world networks are typically short and They are also comparable to average path lengths of the same sized random graphs.\
->For small-sized networks with less than 400 nodes, the average path length is usually high. This can be accreditated to the newness/early stage of a network development, when there are not many connections.\

# Question 3
Creating the second plot showing how APL behaves as p increases from 0 to 0.5 and explaining it.


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#creating a vector of edges from 0 to 1500 with a difference of 50
n<- seq(0,1500,50)  
#p<-seq(0.1,0.5,0.1) 
#creating a vector of 5 p values within the range 0 to 0.5 
p<- c(0.01,0.05,0.1,0.3,0.5)

i<-1
#creating a list-of-lists, where each individual list in the list-of-lists corresponds to the elements of a p-value
myList<-NULL
for(a in p){
j<- 1
gnp<- NULL
for (x in n){
  gnp[[j]] <- sample_gnp(x, a)
  j<- j+1
}
#Appending to the list-of-lists
myList[[i]]<-gnp
i<-i+1
}

i<-1
#creating a list-of-lists, where each individual list in the list-of-lists corresponds to the elements of a p-value
myNewList<-NULL
for(a in myList){
  j<- 1
  gnp.apl.actual<- NULL
  for (x in a){
    gnp.apl.actual[[j]] <- mean_distance(x)
    j<- j+1
  }
  #Appending to the list-of-lists
  myNewList[[i]]<-gnp.apl.actual
  i<-i+1
}

#creating  a dataframe  from the above list-of-lists
dt_list <- map(myNewList, as.data.table)
dt <- rbindlist(dt_list, fill = TRUE, idcol = T)

#renaming the columns
colnames(dt) <-c("p_value",as.character(n))

#creating a tidy dataframe using the pivot_longer function of tidyverse to plot the ggplot graphs
tidy_df_dt <- pivot_longer(dt,-p_value,names_to="Num_vertices",values_to="avg_path_length")

#casting the p-value column as integer(which was of character type)
tidy_df_dt[, 2] <- sapply(tidy_df_dt[, 2], as.integer)

#Assigning the actual p-values
tidy_df_dt$p_value[tidy_df_dt$p_value==1]<-"0.01"
tidy_df_dt$p_value[tidy_df_dt$p_value==2]<-"0.05"
tidy_df_dt$p_value[tidy_df_dt$p_value==3]<-"0.1"
tidy_df_dt$p_value[tidy_df_dt$p_value==4]<-"0.3"
tidy_df_dt$p_value[tidy_df_dt$p_value==5]<-"0.5"

#Plotting the graph
ggplot(tidy_df_dt,aes(x=Num_vertices,y=avg_path_length,colour=p_value))+
  geom_point()+
  geom_line()+
  #scale_color_manual(values=c("red","blue","green","black","orange"),name = "p_value")+
  labs(title ="GNP,p=0.1 to 0.5; Actual Path Length vs n")+
  xlab("Number of Vertices, n")+
  ylab("Average Path Length")+
  theme_bw()+
  theme(axis.text = element_text(size=10),
        axis.title = element_text(size=10),
        legend.title = element_text(face="bold",size=9),
        legend.text = element_text(face="italic",size=10),
        plot.title = element_text(hjust=0.5),
        legend.position = c(0.8, 0.7))
```
We can observe from the graph that as the p value increases the actual path length decreases for a given number of nodes We can also observe that after a p value of 0.1 irrespective of the number of nodes the  average path length doesn't vary much. So from these observations we can say that,as network becomes denser it's easier to communicate or pass information among nodes.

#Appendix

```{r, eval=FALSE}
#creating a vector of edges from 0 to 1500 with a difference of 50
n<- seq(50,1500,50)
p<-0.01
act_list<-NULL
est_list<-NULL

#Iterating for 10 times to get the average
for (a in c(1:10)){
i<- 1
gnp<- NULL
for (x in n){
  gnp[[i]] <- sample_gnp(x, p)
  i<- i+1
}
j<-1
gnp.ave_degree <- NULL
#list to hold all the different estimated values of avg_path_length for different num_of_vertices respectively
gnp.apl.estimate <- NULL
#list to hold all the different actual values of avg_path_length for different num_of_vertices respectively
gnp.apl.actual <- NULL
#Iterating through each graph with different number of vertices
for (x in gnp){
  #calculate average degree : from theorem 1 total degree = 2 x num edges
  # average degree is total degree/number of nodes
  gnp.ave_degree[j] <- 2 * ecount(x)/vcount(x)
  #Estrimated Average path length
  gnp.apl.estimate[j] <- log(n[j])/log(gnp.ave_degree[j])
  #Actual Average path length
  gnp.apl.actual[j] <- mean_distance(x)
  j <-j+1
}
act_list[[a]]<- gnp.apl.actual
est_list[[a]]<- gnp.apl.estimate
}
xxx<-as.data.frame(est_list)
gnp.apl.estimate<-rowMeans(xxx)
yyy<-as.data.frame(act_list)
gnp.apl.actual<-rowMeans(yyy)

#creating  a dataframe from the above variables
df <- data.frame(num_vertices=n, Estimated_APL= gnp.apl.estimate, Actual_APL=gnp.apl.actual)
#creating a tidy dataframe using the pivot_longer function of tidyverse to plot the ggplot graphs
tidy_df <- pivot_longer(df,-num_vertices,names_to="estimate_actual",values_to="avg_path_length")

#Plotting the graph
ggplot(tidy_df,aes(x=num_vertices,y=avg_path_length,colour=estimate_actual,shape=estimate_actual))+
    geom_point()+
    geom_line(aes(linetype=estimate_actual))+
    scale_color_manual(values=c("red","blue"),name = "estimate_actual")+
    scale_shape_manual(values=c(16,18),name = "estimate_actual")+
    scale_linetype_manual(values=c("solid", "longdash"))+
    scale_y_continuous(limits=c(0, 15),breaks= c(0,2,4,5,6,8,10,12,14,15))+
    scale_x_continuous(breaks=c(0,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500))+
    labs(title ="GNP,p=0.01; Average Path Length vs n")+
    xlab("Number of Vertices, n")+
    ylab("Average Path Length")+
    theme_bw()+
    theme(axis.text = element_text(size=10),
          axis.title = element_text(size=10),
          legend.title = element_text(face="bold",size=9),
          legend.text = element_text(face="italic",size=10),
          plot.title = element_text(hjust=0.5),
          legend.position = c(0.8, 0.7))


#creating a vector of edges from 0 to 1500 with a difference of 50
n<- seq(0,1500,50)  
#p<-seq(0.1,0.5,0.1) 
#creating a vector of 5 p values within the range 0 to 0.5 
p<- c(0.01,0.05,0.1,0.3,0.5)

i<-1
#creating a list-of-lists, where each individual list in the list-of-lists corresponds to the elements of a p-value
myList<-NULL
for(a in p){
j<- 1
gnp<- NULL
for (x in n){
  gnp[[j]] <- sample_gnp(x, a)
  j<- j+1
}
#Appending to the list-of-lists
myList[[i]]<-gnp
i<-i+1
}

i<-1
#creating a list-of-lists, where each individual list in the list-of-lists corresponds to the elements of a p-value
myNewList<-NULL
for(a in myList){
  j<- 1
  gnp.apl.actual<- NULL
  for (x in a){
    gnp.apl.actual[[j]] <- mean_distance(x)
    j<- j+1
  }
  #Appending to the list-of-lists
  myNewList[[i]]<-gnp.apl.actual
  i<-i+1
}

#creating  a dataframe  from the above list-of-lists
dt_list <- map(myNewList, as.data.table)
dt <- rbindlist(dt_list, fill = TRUE, idcol = T)

#renaming the columns
colnames(dt) <-c("p_value",as.character(n))

#creating a tidy dataframe using the pivot_longer function of tidyverse to plot the ggplot graphs
tidy_df_dt <- pivot_longer(dt,-p_value,names_to="Num_vertices",values_to="avg_path_length")

#casting the p-value column as integer(which was of character type)
tidy_df_dt[, 2] <- sapply(tidy_df_dt[, 2], as.integer)

#Assigning the actual p-values
tidy_df_dt$p_value[tidy_df_dt$p_value==1]<-"0.01"
tidy_df_dt$p_value[tidy_df_dt$p_value==2]<-"0.05"
tidy_df_dt$p_value[tidy_df_dt$p_value==3]<-"0.1"
tidy_df_dt$p_value[tidy_df_dt$p_value==4]<-"0.3"
tidy_df_dt$p_value[tidy_df_dt$p_value==5]<-"0.5"

#Plotting the graph
ggplot(tidy_df_dt,aes(x=Num_vertices,y=avg_path_length,colour=p_value))+
  geom_point()+
  geom_line()+
  #scale_color_manual(values=c("red","blue","green","black","orange"),name = "p_value")+
  labs(title ="GNP,p=0.1 to 0.5; Actual Path Length vs n")+
  xlab("Number of Vertices, n")+
  ylab("Average Path Length")+
  theme_bw()+
  theme(axis.text = element_text(size=10),
        axis.title = element_text(size=10),
        legend.title = element_text(face="bold",size=9),
        legend.text = element_text(face="italic",size=10),
        plot.title = element_text(hjust=0.5),
        legend.position = c(0.8, 0.7))

```

